import argparse
import os
import sys
import json
import subprocess
import shutil
import time

from versionReader import VersionReader
from remoteVersionChecker import RemoteVersionChecker
from downloader import Downloader
from unpacker import Unpacker

class PyGitUpdater:
    
    def __init__(self, config_file_path, force_update):
        # If the application is run as a bundle (i.e., an executable generated by PyInstaller),
        # the PyInstaller bootloader sets the attribute sys._MEIPASS, which is the path to the
        # temporary directory where the data files are unpacked.
        if getattr(sys, 'frozen', False):
            application_path = sys._MEIPASS
            print("Application path when bundled:", application_path)
            # Copy the config.json file to the temporary directory
            shutil.copyfile(config_file_path, os.path.join(application_path, 'config.json'))
            config_file_path = os.path.join(application_path, 'config.json')
        else:
            application_path = os.path.dirname(os.path.abspath(__file__))
            print("Application path when not bundled:", application_path)
        config_file_path = os.path.join(application_path, config_file_path)
        print("Final config file path:", config_file_path)

        try:
            with open(config_file_path) as f:
                self.config = json.load(f)
        except FileNotFoundError:
            print(f"Error: The config file {config_file_path} was not found.")
            sys.exit(1)

        #print("Config content:", self.config)
        #print(f"Force update value from config file: {self.config.get('force_update', False)}")
        ##print(f"Force update value from command line argument: {force_update}")

        # If force_update is not passed as a command-line argument, use the force_update value from the JSON file
        self.config['force_update'] = self.config.get('force_update', False) if force_update is None else force_update

        #print(f"Final force update value: {self.config['force_update']}")

        self.version_reader = VersionReader(self.config['json_local_path'])
        self.version_checker = RemoteVersionChecker(self.config['github_url'], self.config.get('prefix'))
        self.downloader = Downloader(self.config['github_url'], self.config.get('direct_download'), self.config.get('download_path'))
    

    def terminate_process(self):
        # Terminate a process by its name
        process_name_pre_update = self.config.get('process_name_pre_update')
        if process_name_pre_update:
            subprocess.run(["taskkill", "/IM", process_name_pre_update, "/F"])




    def start_process(self):
        # Start a process by its name after a short delay
        time.sleep(0.05)
        executable_name_post_update = self.config.get('executable_name_post_update')
        args_post_update = self.config.get('args_post_update', "")
        
        # Check for specific flags in the arguments
        if "-NoUpdate" in args_post_update: 
            print("-NoUpdate find")
        if "-PostUpdate" in args_post_update: 
            print("-PostUpdate find")

        # If the executable name is provided, proceed to run it
        if executable_name_post_update:
            # Ensure that args_post_update is a list of arguments, not a single string
            args_list = args_post_update.split() if args_post_update else []
            # Execute the command with subprocess.Popen
            subprocess.Popen([executable_name_post_update] + args_list)



    def update(self):
        local_version = self.version_reader.get_version()
        remote_version = self.version_checker.get_version()
        print("local version: ",local_version,"   remote version: ",remote_version)

        if (local_version < remote_version) or self.config.get('force_update', False):
            print(f"New version {remote_version} is available. Current version is {local_version}.")

            if self.config.get('force_update', False): print("Update forced")

            # Terminate the process before the update, if specified
            self.terminate_process()

            # Download and Extract with Prefix new_
            
            file_path = self.downloader.download_file()
            unpacker = Unpacker(download_path=os.path.dirname(file_path), prefix='new_', untouch=self.config.get('untouch', []))
            unpacker.extract_and_rename(file_path)

            # Start the process after the update, if specified
            self.start_process()

        else:
            print("You are up-to-date!")


# Create a parser for command-line arguments
parser = argparse.ArgumentParser()
parser.add_argument('--force', action='store_true', default=None, help='Force the update')

# Parse the command-line arguments
args = parser.parse_args()

updater = PyGitUpdater("config.json", args.force)
updater.update()
